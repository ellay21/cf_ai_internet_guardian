{
  "version": 3,
  "sources": ["../bundle-outqRx/strip-cf-connecting-ip-header.js", "../../../src/worker.js", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-outqRx/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-outqRx/middleware-loader.entry.ts"],
  "sourceRoot": "C:\\Users\\Ellay Mesud\\Pictures\\Cloudflare\\cf_ai_internet_guardian\\.wrangler\\tmp\\dev-jqeEiP",
  "sourcesContent": ["function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "/**\r\n * Cloudflare Workers AI Internet Guardian Backend v2.0\r\n * \r\n * Features:\r\n * - Turnstile bot-protection verification\r\n * - Domain enrichment (DNS, TLS, optional Radar API)\r\n * - Advanced AI analysis with structured prompting\r\n * - KV-based analysis history with enrichment snapshots\r\n * - Comprehensive error handling and logging\r\n */\r\n\r\n// ============================================================================\r\n// CORS Configuration\r\n// ============================================================================\r\n\r\nconst ALLOWED_ORIGINS = [\r\n  'http://localhost:3000',\r\n  'http://localhost:5173',\r\n  'http://127.0.0.1:3000',\r\n  'http://127.0.0.1:5173',\r\n];\r\n\r\n/**\r\n * Apply CORS headers to response\r\n * @param {Response} response - The response object\r\n * @param {string} origin - The request origin\r\n * @returns {Response} Response with CORS headers\r\n */\r\nfunction addCORSHeaders(response, origin) {\r\n  const isAllowedOrigin = ALLOWED_ORIGINS.includes(origin);\r\n\r\n  if (isAllowedOrigin) {\r\n    response.headers.set('Access-Control-Allow-Origin', origin);\r\n    response.headers.set('Access-Control-Allow-Methods', 'GET, POST, OPTIONS, PUT, DELETE');\r\n    response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');\r\n    response.headers.set('Access-Control-Max-Age', '3600');\r\n  }\r\n\r\n  return response;\r\n}\r\n\r\n// ============================================================================\r\n// Turnstile Verification\r\n// ============================================================================\r\n\r\n/**\r\n * Verify Turnstile token with Cloudflare\r\n * @param {string} token - The Turnstile token from client\r\n * @param {string} secret - Turnstile secret key from env\r\n * @returns {Promise<{success: boolean, error_codes?: string[]}>}\r\n */\r\nasync function verifyTurnstile(token, secret) {\r\n  if (!token || !secret) {\r\n    return { success: false, error_codes: ['missing_token_or_secret'] };\r\n  }\r\n\r\n  try {\r\n    const response = await fetch('https://challenges.cloudflare.com/turnstile/v0/siteverify', {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        secret: secret,\r\n        response: token,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(`Turnstile API returned ${response.status}`);\r\n    }\r\n\r\n    const result = await response.json();\r\n    return result;\r\n  } catch (error) {\r\n    console.error('Turnstile verification error:', error);\r\n    return { success: false, error_codes: ['verification_error'] };\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Domain Enrichment\r\n// ============================================================================\r\n\r\n/**\r\n * Extract hostname from URL\r\n * @param {string} url - The full URL\r\n * @returns {string} Hostname\r\n */\r\nfunction getHostname(url) {\r\n  try {\r\n    return new URL(url).hostname;\r\n  } catch (e) {\r\n    return '';\r\n  }\r\n}\r\n\r\n/**\r\n * Perform lightweight domain enrichment\r\n * - Check TLS/HTTPS availability\r\n * - Extract security headers\r\n * - Optional: Call Cloudflare Radar API if key available\r\n * @param {string} url - The URL to analyze\r\n * @param {Env} env - Worker environment\r\n * @returns {Promise<Object>} Enrichment data\r\n */\r\nasync function enrichDomain(url, env) {\r\n  const enrichment = {\r\n    url: url,\r\n    hostname: getHostname(url),\r\n    https: url.startsWith('https://'),\r\n    tls_verified: false,\r\n    hsts_present: false,\r\n    security_headers: {},\r\n    is_cloudflare: false,\r\n    dns_resolvable: false,\r\n    radar_data: null,\r\n    enrichment_timestamp: new Date().toISOString(),\r\n  };\r\n\r\n  try {\r\n    // Attempt HEAD request to gather security headers and TLS info\r\n    const headResponse = await fetch(url, {\r\n      method: 'HEAD',\r\n      redirect: 'follow',\r\n    }).catch(() => null);\r\n\r\n    if (headResponse) {\r\n      enrichment.tls_verified = headResponse.ok || headResponse.status < 500;\r\n      enrichment.is_cloudflare =\r\n        headResponse.headers.get('Server')?.toLowerCase().includes('cloudflare') ||\r\n        headResponse.headers.get('CF-RAY') !== null;\r\n\r\n      // Extract security headers\r\n      const hsts = headResponse.headers.get('Strict-Transport-Security');\r\n      const csp = headResponse.headers.get('Content-Security-Policy');\r\n      const xframe = headResponse.headers.get('X-Frame-Options');\r\n\r\n      enrichment.hsts_present = !!hsts;\r\n      if (csp) enrichment.security_headers.csp = csp.substring(0, 100);\r\n      if (xframe) enrichment.security_headers.x_frame_options = xframe;\r\n    }\r\n\r\n    // Optional: Call Cloudflare Radar API if secret is available\r\n    if (env.RADAR_API_KEY) {\r\n      enrichment.radar_data = await getRadarData(enrichment.hostname, env.RADAR_API_KEY);\r\n    }\r\n\r\n    enrichment.dns_resolvable = enrichment.tls_verified;\r\n  } catch (error) {\r\n    console.warn('Domain enrichment warning:', error.message);\r\n    // Enrichment is optional; continue without it\r\n  }\r\n\r\n  return enrichment;\r\n}\r\n\r\n/**\r\n * Fetch domain reputation from Cloudflare Radar API (optional)\r\n * @param {string} hostname - Domain hostname\r\n * @param {string} apiKey - Radar API key\r\n * @returns {Promise<Object|null>} Radar data or null if unavailable\r\n */\r\nasync function getRadarData(hostname, apiKey) {\r\n  try {\r\n    const response = await fetch(\r\n      `https://api.cloudflare.com/client/v4/radar/domain?domain=${hostname}`,\r\n      {\r\n        headers: {\r\n          'Authorization': `Bearer ${apiKey}`,\r\n          'Content-Type': 'application/json',\r\n        },\r\n      }\r\n    );\r\n\r\n    if (!response.ok) {\r\n      console.warn('Radar API returned', response.status);\r\n      return null;\r\n    }\r\n\r\n    const data = await response.json();\r\n    return data.result || null;\r\n  } catch (error) {\r\n    console.warn('Radar API error:', error.message);\r\n    return null;\r\n  }\r\n}\r\n\r\n\r\n// ============================================================================\r\n// KV Storage Management\r\n// ============================================================================\r\n\r\n/**\r\n * Store URL analysis in KV with enrichment data\r\n * @param {KVNamespace} kv - KV namespace binding\r\n * @param {string} url - The URL analyzed\r\n * @param {Object} analysis - The analysis result\r\n * @param {Object} enrichment - Enrichment data\r\n * @param {boolean} turnstile_verified - Turnstile verification status\r\n * @returns {Promise<void>}\r\n */\r\nasync function storeAnalysis(kv, url, analysis, enrichment, turnstile_verified) {\r\n  const timestamp = new Date().toISOString();\r\n  const entry = {\r\n    url,\r\n    analysis: analysis.analysis,\r\n    reason: analysis.reason,\r\n    next_steps: analysis.next_steps,\r\n    timestamp,\r\n    turnstile_verified,\r\n    enrichment: {\r\n      hostname: enrichment.hostname,\r\n      https: enrichment.https,\r\n      hsts_present: enrichment.hsts_present,\r\n      is_cloudflare: enrichment.is_cloudflare,\r\n    },\r\n  };\r\n\r\n  // Get existing history\r\n  let history = [];\r\n  try {\r\n    const existing = await kv.get('analysis_history', 'json');\r\n    if (existing) {\r\n      history = existing;\r\n    }\r\n  } catch (e) {\r\n    console.log('No existing history found, starting fresh');\r\n  }\r\n\r\n  // Add new entry and keep only last 10\r\n  history.unshift(entry);\r\n  history = history.slice(0, 10);\r\n\r\n  // Store back to KV\r\n  await kv.put('analysis_history', JSON.stringify(history));\r\n}\r\n\r\n/**\r\n * Get analysis history from KV\r\n * @param {KVNamespace} kv - KV namespace binding\r\n * @returns {Promise<Array>} Array of past analyses\r\n */\r\nasync function getAnalysisHistory(kv) {\r\n  try {\r\n    const history = await kv.get('analysis_history', 'json');\r\n    return history || [];\r\n  } catch (e) {\r\n    console.error('History retrieval error:', e);\r\n    return [];\r\n  }\r\n}\r\n\r\n\r\n// ============================================================================\r\n// URL Analysis with Workers AI\r\n// ============================================================================\r\n\r\n/**\r\n * Construct system prompt with context awareness\r\n * @param {Object} enrichment - Domain enrichment data\r\n * @param {boolean} isUrl - Whether input is a URL\r\n * @param {boolean} isFirstQuery - Whether this is the first query in session\r\n * @returns {string} System prompt\r\n */\r\nfunction getSystemPrompt(enrichment, isUrl, isFirstQuery = false) {\r\n  let basePrompt = `You are Internet Guardian, an AI security expert for URL and internet safety analysis.\r\n\r\nYour role: Analyze URLs for security threats and answer questions about internet security.\r\nYour scope: URL safety, phishing, malware, security best practices, cyber threats.\r\n\r\nResponse format for URLs:\r\nVERDICT: [SAFE | SUSPICIOUS | RISKY]\r\nEXPLANATION: [2-line clear explanation for non-experts]\r\nNEXT_STEPS: [Two recommended actions, separated by semicolon]\r\n\r\nResponse format for security questions:\r\nANSWER: [Clear, helpful answer about internet security]\r\nSAFETY_TIP: [One practical security tip related to the question]\r\n\r\nOut-of-scope handling:\r\nIf user asks about non-security topics (finance, weather, politics, etc.):\r\nTYPE: OFF_TOPIC\r\nRESPONSE: Politely explain you only handle internet security and URL safety topics`;\r\n\r\n  if (isFirstQuery) {\r\n    basePrompt += `\r\n\r\nGREETING: Start with a friendly greeting like \"\uD83D\uDC4B Welcome to Internet Guardian! I'm here to help you stay safe online.\"`;\r\n  }\r\n\r\n  if (isUrl) {\r\n    basePrompt += `\r\n\r\nURL Analysis Context:\r\nEnrichment Facts:\r\n${JSON.stringify(enrichment, null, 2)}\r\n\r\nBase assessment on:\r\n1. Domain legitimacy and TLS status\r\n2. Security headers and HSTS presence\r\n3. Common phishing/malware patterns\r\n4. URL structure and encoding anomalies`;\r\n  }\r\n\r\n  return basePrompt;\r\n}\r\n\r\n/**\r\n * Analyze URL safety or general query using Cloudflare Workers AI with context awareness\r\n * @param {Env} env - Worker environment with AI binding\r\n * @param {string} urlOrQuery - The URL or general query to analyze\r\n * @param {Object} enrichment - Enrichment data (optional, for URLs only)\r\n * @param {boolean} isFirstQuery - Whether this is the first query in session\r\n * @returns {Promise<Object>} Analysis result\r\n */\r\nasync function analyzeURL(env, urlOrQuery, enrichment, isFirstQuery = false) {\r\n  // Check if it's a URL or a general query\r\n  let isUrl = false;\r\n  let hostname = '';\r\n  \r\n  try {\r\n    new URL(urlOrQuery);\r\n    isUrl = true;\r\n    hostname = getHostname(urlOrQuery);\r\n  } catch (e) {\r\n    // Not a valid URL - treat as general query\r\n    isUrl = false;\r\n  }\r\n\r\n  // For non-URLs, use minimal enrichment\r\n  if (!isUrl && !enrichment) {\r\n    enrichment = {\r\n      hostname: 'general_query',\r\n      https: null,\r\n      hsts_present: null,\r\n      is_cloudflare: null,\r\n      security_headers: [],\r\n    };\r\n  }\r\n\r\n  const systemPrompt = getSystemPrompt(enrichment, isUrl, isFirstQuery);\r\n  const userPrompt = isUrl \r\n    ? `Analyze this URL for security threats: ${urlOrQuery}`\r\n    : `Answer this security-related question: ${urlOrQuery}`;\r\n\r\n  try {\r\n    // Call Cloudflare Workers AI\r\n    const response = await env.AI.run('@cf/meta/llama-2-7b-chat-int8', {\r\n      messages: [\r\n        {\r\n          role: 'system',\r\n          content: systemPrompt,\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: userPrompt,\r\n        },\r\n      ],\r\n    });\r\n\r\n    // Parse AI response\r\n    const aiResponse = response.response || '';\r\n\r\n    // Check if response indicates off-topic question\r\n    if (aiResponse.match(/TYPE:\\s*OFF_TOPIC/i)) {\r\n      return {\r\n        analysis: 'OFF_TOPIC',\r\n        reason: aiResponse.match(/RESPONSE:\\s*(.+?)(?:\\n|$)/i)?.[1] || 'This question is outside my expertise. I focus on internet security and URL safety.',\r\n        next_steps: 'Please ask me about URLs, phishing, malware, or other internet security topics.',\r\n        isOffTopic: true,\r\n      };\r\n    }\r\n\r\n    // Check if this is a greeting response (first query)\r\n    const greetingMatch = aiResponse.match(/GREETING:\\s*(.+?)(?:\\n|$)/i);\r\n\r\n    if (isUrl) {\r\n      // URL Analysis Response\r\n      const verdictMatch = aiResponse.match(/VERDICT:\\s*(SAFE|SUSPICIOUS|RISKY)/i);\r\n      const explanationMatch = aiResponse.match(/EXPLANATION:\\s*(.+?)(?:NEXT_STEPS:|$)/is);\r\n      const nextStepsMatch = aiResponse.match(/NEXT_STEPS:\\s*(.+?)(?:\\n|$)/);\r\n\r\n      const verdict = verdictMatch ? verdictMatch[1].toUpperCase() : 'UNKNOWN';\r\n      const explanation = explanationMatch ? explanationMatch[1].trim() : 'Unable to determine safety status';\r\n      const nextSteps = nextStepsMatch ? nextStepsMatch[1].trim() : 'No recommendations available';\r\n\r\n      return {\r\n        analysis: verdict,\r\n        reason: (greetingMatch ? greetingMatch[1] + '\\n\\n' : '') + explanation,\r\n        next_steps: nextSteps,\r\n        type: 'URL_ANALYSIS',\r\n        fullResponse: aiResponse,\r\n      };\r\n    } else {\r\n      // General Security Question Response\r\n      const answerMatch = aiResponse.match(/ANSWER:\\s*(.+?)(?:SAFETY_TIP:|$)/is);\r\n      const tipMatch = aiResponse.match(/SAFETY_TIP:\\s*(.+?)(?:\\n|$)/);\r\n\r\n      const answer = answerMatch ? answerMatch[1].trim() : aiResponse;\r\n      const tip = tipMatch ? tipMatch[1].trim() : '';\r\n\r\n      return {\r\n        analysis: 'QUESTION_ANSWERED',\r\n        reason: (greetingMatch ? greetingMatch[1] + '\\n\\n' : '') + answer,\r\n        next_steps: tip || 'Stay vigilant about internet security!',\r\n        type: 'GENERAL_QUERY',\r\n        fullResponse: aiResponse,\r\n      };\r\n    }\r\n  } catch (error) {\r\n    console.error('AI Analysis Error:', error);\r\n    throw new Error('Failed to analyze: ' + error.message);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Route Handlers\r\n// ============================================================================\r\n\r\n/**\r\n * Handle health check endpoint\r\n * @returns {Response} Health status\r\n */\r\nfunction handleHealthCheck() {\r\n  return new Response(\r\n    JSON.stringify({\r\n      status: 'ok',\r\n      service: 'cf_ai_internet_guardian',\r\n      version: '2.0',\r\n      features: ['turnstile', 'domain_enrichment', 'workers_ai', 'kv_history'],\r\n    }),\r\n    {\r\n      status: 200,\r\n      headers: { 'Content-Type': 'application/json' },\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Handle URL analysis endpoint with Turnstile verification\r\n * @param {Request} request - The incoming request\r\n * @param {Env} env - Worker environment\r\n * @returns {Promise<Response>} Analysis response\r\n */\r\nasync function handleAnalyze(request, env) {\r\n  if (request.method === 'OPTIONS') {\r\n    return new Response(null, { status: 204 });\r\n  }\r\n\r\n  if (request.method !== 'POST') {\r\n    return new Response(\r\n      JSON.stringify({ error: 'Method not allowed. Use POST.' }),\r\n      { status: 405, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n\r\n  try {\r\n    const body = await request.json();\r\n    const { url, turnstile_token, sessionId } = body;\r\n\r\n    // Validate inputs\r\n    if (!url) {\r\n      return new Response(\r\n        JSON.stringify({ error: 'URL is required' }),\r\n        { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n\r\n    // Check if this is first query (via sessionId from frontend)\r\n    let isFirstQuery = false;\r\n    let sessionVerified = false;\r\n    \r\n    if (sessionId) {\r\n      const sessionKey = `session:${sessionId}`;\r\n      const sessionMarker = await env.CHAT_MEMORY.get(sessionKey);\r\n      \r\n      if (!sessionMarker) {\r\n        // First query in this session - requires Turnstile verification\r\n        isFirstQuery = true;\r\n      } else {\r\n        // Session already verified\r\n        sessionVerified = true;\r\n      }\r\n    }\r\n\r\n    // Verify Turnstile token ONLY on first query\r\n    if (isFirstQuery) {\r\n      if (!turnstile_token) {\r\n        return new Response(\r\n          JSON.stringify({ error: 'Turnstile token is required for first query' }),\r\n          { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n\r\n      const turnstileSecret = env.TURNSTILE_SECRET;\r\n      if (!turnstileSecret) {\r\n        console.error('TURNSTILE_SECRET not configured');\r\n        return new Response(\r\n          JSON.stringify({ error: 'Server misconfiguration' }),\r\n          { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n\r\n      const turnstileResult = await verifyTurnstile(turnstile_token, turnstileSecret);\r\n      if (!turnstileResult.success) {\r\n        console.warn('Turnstile verification failed:', turnstileResult.error_codes);\r\n        return new Response(\r\n          JSON.stringify({\r\n            error: 'Turnstile verification failed',\r\n            details: turnstileResult.error_codes,\r\n          }),\r\n          { status: 403, headers: { 'Content-Type': 'application/json' } }\r\n        );\r\n      }\r\n\r\n      // Mark session as verified\r\n      if (sessionId) {\r\n        const sessionKey = `session:${sessionId}`;\r\n        await env.CHAT_MEMORY.put(sessionKey, 'verified', { expirationTtl: 3600 }); // 1 hour session\r\n      }\r\n    }\r\n\r\n    // For URLs, enrich domain with security data\r\n    // For general queries, skip enrichment\r\n    let enrichment = null;\r\n    let isUrl = false;\r\n    \r\n    try {\r\n      new URL(url);\r\n      isUrl = true;\r\n      enrichment = await enrichDomain(url, env);\r\n    } catch (e) {\r\n      // Not a URL - general query\r\n      isUrl = false;\r\n      enrichment = {\r\n        hostname: 'general_query',\r\n        https: null,\r\n        hsts_present: null,\r\n        is_cloudflare: null,\r\n        security_headers: [],\r\n      };\r\n    }\r\n\r\n    // Check if this is first query (via sessionId from frontend)\r\n    // Already verified above - now just pass the flag to analyzeURL\r\n    const analysis = await analyzeURL(env, url, enrichment, isFirstQuery);\r\n\r\n    // Store in KV with enrichment and Turnstile status\r\n    await storeAnalysis(env.CHAT_MEMORY, url, analysis, enrichment, true);\r\n\r\n    // Build response with type information\r\n    const responseBody = {\r\n      type: analysis.type || (isUrl ? 'URL_ANALYSIS' : 'GENERAL_QUERY'),\r\n      analysis: analysis.analysis,\r\n      reason: analysis.reason,\r\n      next_steps: analysis.next_steps,\r\n      isOffTopic: analysis.isOffTopic || false,\r\n      enrichment: isUrl ? {\r\n        https: enrichment.https,\r\n        hsts_present: enrichment.hsts_present,\r\n        is_cloudflare: enrichment.is_cloudflare,\r\n      } : null,\r\n      timestamp: new Date().toISOString(),\r\n    };\r\n\r\n    return new Response(\r\n      JSON.stringify(responseBody),\r\n      { status: 200, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  } catch (error) {\r\n    console.error('Analyze endpoint error:', error);\r\n    return new Response(\r\n      JSON.stringify({ error: error.message }),\r\n      { status: 400, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Handle history endpoint\r\n * @param {Env} env - Worker environment\r\n * @returns {Promise<Response>} Analysis history\r\n */\r\nasync function handleHistory(env) {\r\n  try {\r\n    const history = await getAnalysisHistory(env.CHAT_MEMORY);\r\n    return new Response(\r\n      JSON.stringify({ history }),\r\n      { status: 200, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  } catch (error) {\r\n    console.error('History endpoint error:', error);\r\n    return new Response(\r\n      JSON.stringify({ error: error.message }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Handle Turnstile site key retrieval (public endpoint)\r\n * @param {Env} env - Worker environment\r\n * @returns {Response} Turnstile site key\r\n */\r\nfunction handleTurnstileSiteKey(env) {\r\n  const siteKey = env.TURNSTILE_SITE_KEY;\r\n  if (!siteKey) {\r\n    return new Response(\r\n      JSON.stringify({ error: 'Turnstile site key not configured' }),\r\n      { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n\r\n  return new Response(\r\n    JSON.stringify({ site_key: siteKey }),\r\n    { status: 200, headers: { 'Content-Type': 'application/json' } }\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// Request Router\r\n// ============================================================================\r\n\r\n/**\r\n * Route incoming requests to appropriate handlers\r\n * @param {Request} request - The incoming request\r\n * @param {Env} env - Worker environment\r\n * @returns {Promise<Response>} Response from appropriate handler\r\n */\r\nasync function handleRequest(request, env) {\r\n  const url = new URL(request.url);\r\n  const pathname = url.pathname;\r\n  const origin = request.headers.get('origin') || '';\r\n\r\n  // Route to appropriate handler\r\n  if (pathname === '/health') {\r\n    return handleHealthCheck();\r\n  } else if (pathname === '/api/analyze') {\r\n    const response = await handleAnalyze(request, env);\r\n    return addCORSHeaders(response, origin);\r\n  } else if (pathname === '/api/history') {\r\n    const response = await handleHistory(env);\r\n    return addCORSHeaders(response, origin);\r\n  } else if (pathname === '/api/turnstile-site-key') {\r\n    const response = handleTurnstileSiteKey(env);\r\n    return addCORSHeaders(response, origin);\r\n  } else {\r\n    return new Response(\r\n      JSON.stringify({\r\n        error: 'Not found',\r\n        endpoints: ['/health', '/api/analyze', '/api/history', '/api/turnstile-site-key'],\r\n      }),\r\n      { status: 404, headers: { 'Content-Type': 'application/json' } }\r\n    );\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Worker Export\r\n// ============================================================================\r\n\r\nexport default {\r\n  async fetch(request, env) {\r\n    try {\r\n      return await handleRequest(request, env);\r\n    } catch (error) {\r\n      console.error('Unhandled error:', error);\r\n      return new Response(\r\n        JSON.stringify({ error: 'Internal server error' }),\r\n        { status: 500, headers: { 'Content-Type': 'application/json' } }\r\n      );\r\n    }\r\n  },\r\n};\r\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"C:\\\\Users\\\\Ellay Mesud\\\\Pictures\\\\Cloudflare\\\\cf_ai_internet_guardian\\\\src\\\\worker.js\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"C:\\\\Users\\\\Ellay Mesud\\\\Pictures\\\\Cloudflare\\\\cf_ai_internet_guardian\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"C:\\\\Users\\\\Ellay Mesud\\\\Pictures\\\\Cloudflare\\\\cf_ai_internet_guardian\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"C:\\\\Users\\\\Ellay Mesud\\\\Pictures\\\\Cloudflare\\\\cf_ai_internet_guardian\\\\src\\\\worker.js\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"C:\\\\Users\\\\Ellay Mesud\\\\Pictures\\\\Cloudflare\\\\cf_ai_internet_guardian\\\\.wrangler\\\\tmp\\\\bundle-outqRx\\\\middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"C:\\\\Users\\\\Ellay Mesud\\\\Pictures\\\\Cloudflare\\\\cf_ai_internet_guardian\\\\node_modules\\\\wrangler\\\\templates\\\\middleware\\\\common.ts\";\nimport type { WorkerEntrypointConstructor } from \"C:\\\\Users\\\\Ellay Mesud\\\\Pictures\\\\Cloudflare\\\\cf_ai_internet_guardian\\\\.wrangler\\\\tmp\\\\bundle-outqRx\\\\middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"C:\\\\Users\\\\Ellay Mesud\\\\Pictures\\\\Cloudflare\\\\cf_ai_internet_guardian\\\\.wrangler\\\\tmp\\\\bundle-outqRx\\\\middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": []
}
